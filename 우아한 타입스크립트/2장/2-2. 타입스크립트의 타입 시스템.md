## 2-2. 타입스크립트의 타입 시스템

### 1. 타입 에너테이션 방식

: 타입 에너테이션이란 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법이다. 언어마다 타입을 명시해주는 방법이 다르다.

**타입스크립트의 타입 선언 방식 예시**

```ts
let isDone: boolean = false;
let decimal: number = 6;
let color: string = "blue";
let list: number[] = [1, 2, 3];
let x: [string, number]; // tuple
```

### 2. 구조적 타이핑

: 타입을 사용하는 여러 프로그래밍 언어에서 값이나 객체는 하나의 구체적인 타입을 가지고 있다. 타입은 이름으로 구분되며 컴파일타임 이후에도 남아있다. 이것을 **명목적으로 구제화한 타입 시스템**이라고 부르기도 한다.

또한 서로 다른 클래스끼리 명확한 상속 관계나 공통으로 가지고 있는 인터페이스가 없다면 타입은 서로 호환되지 않는다.

```ts
interface Developer {
  faceValue: number;
}

interface BankNote {
  faceValue: number;
}

let developer: Developer = { faceValue: 52 };
let bankNote: BankNote = { faceValue: 100000 };

developer = bankNote; // OK
bankNote = developer; // OK
```

그러나 타입스크립트에서 타입을 구분하는 방식이 조금 다르다.
이름으로 타입을 구분하는 명목적인 타입 언어의 특징과 달리 타입스크립트는 구조로 타입을 구분한다. 이것을 **_구조적 타이핑_** 이라고 한다.

### 3. 구조적 서브타이핑

: 타입스크립트의 타입은 값의 집합으로 생각할 수 있다. 타입은 단지 집합에 포함되어 있는 값이고 특정 값은 많은 집합에 포함될 수 있다. 따라서 타입스크립트에서는 특정 값이 string 또는 number 타입을 동시에 가질 수 있다.

```ts
type stringOrNumber = string | number;
```

-> 이처럼 집합으로 나타낼 수 있는 타입스크립트의 타입 시스템을 지탱하고 있는 개념이 바로 구조적 서브타이핑이다.

구조적 서브타이핑이란?
객체가 가지고 있는 속성(프로퍼티)을 바탕으로 타입을 구분하는 것이다. 이름이 다른 객체라도 가진 속성이 동이라하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여긴다.

```ts
interface Pet {
  name: string;
}

interface Cat {
  name: string;
  age: number;
}

let pet: Pet;
let cat: Cat = { name: "Zag", age: 2 };

pet = cat; // 가능!
```

Cat은 Pet과 다른 타입으로 선언되었지만 Pet이 갖고 있는 name이라는 속성을 가지고 있다. 따라서 Cat 타입으로 선언한 cat을 Pet 타입으로 선헌한 pet에 할당할 수 있다.

```ts
interface Pet {
  name: string;
}

let cat = { name: "Zag", age: 2 };
function greet(pet: Pet) {
  console.log("Hello, " + pet.name);
}

greet(cat); // 가능!
```

greet() 함수의 매개변수에 들어갈 수 있는 값은 Pet 타입으로 제한되어 있다. 그러나 타입을 명시하지 않은 cat 객체를 greet() 함수의 인자로 전달해도 코드는 정상적으로 실행된다. cat 객체는 Pet 인터페이스가 가지고 있는 name 속성을 가지고 있어 pet.name의 방식으로 name 속성에 접근할 수 있기 때문이다.

위와 같은 타이핑 방식이 구조적 타이핑이다. 구조적 서브타이핑에서도 알 수 있듯이 타입스크립트의 서브타이핑, 즉 타입의 상속 역시 구조적 타이핑을 기반으로 하고 있다. 클래스를 사용한 다음 예시를 살펴보자.

```ts
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

class Developer {
  name: string;
  age: number;
  sleepTime: number;

  constructor(name: string, age: number, sleepTime: number) {
    this.name = name;
    this.age = age;
    this.sleepTime = sleepTime;
  }
}

function greet(p: Person) {
  console.log(`Hello, I'm ${p.name}`);
}

const developer = new Developer("zig", 20, 7);

greet(developer); // Hello, I'm zig
```

Developer 클래스가 Person 클래스를 상속받지 않았는데도 greet(developer)는 정상적으로 동작한다. Developer는 Person이 갖고 있는 속성을 가지고 있기 때문이다.

서로 다른 두 타입간의 호환성은 오로지 타입 내부의 구조에 의해 결정된다. 타입 A가 타입 B의 서브타입이라면 A타입의 인스터느는 B타입이 필요한 곳에 언제든지 위치할 수 있다. 즉, 타입이 계층 구조로부터 자유롭다.
